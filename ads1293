from TI2093RegList import *
from TI2093RegSetting import *
import spidev
import time
import RPi.GPIO as GPIO
from enum import Enum
import numpy as np

valve = 8000
gpio1 = 17

class ECG_LEAD_TYPE(Enum):
  LEAD_03 = 3
  LEAD_05 = 5
  LEAD_12 = 12


class ADS1293(object):

  def __init__(self, leads=ECG_LEAD_TYPE.LEAD_05, max_speed_hz=200000):
    self._DATA_READY_SLEEP_INTERVAL   = 0.009 #raspberry pi zero w required sleep mainly initially
    self.TI_ADS1293_CONFIG_REG_VALUE  = (0x00)
    self.GPIO_INPUT_PIN               = 17

    self.result, self.a = None,None#data

    self.leads = leads
    self.adc_data_ready_count = 0

    GPIO.setmode(GPIO.BCM)
    GPIO.setup(self.GPIO_INPUT_PIN, GPIO.IN , pull_up_down=GPIO.PUD_UP)


    self.spi_0 = None
    self.spi_1 = None
    self.spi_2 = None

    if(leads == ECG_LEAD_TYPE.LEAD_05):
      self.spi_0 = spidev.SpiDev()
      self.spi_0.open(0, 0)
      self.spi_0.max_speed_hz = max_speed_hz
    elif (leads == ECG_LEAD_TYPE.LEAD_12):
      self.spi_0 = spidev.SpiDev()
      self.spi_0.open(1, 0)
      self.spi_0.max_speed_hz = max_speed_hz

      self.spi_1 = spidev.SpiDev()
      self.spi_1.open(1, 1)
      self.spi_1.max_speed_hz = max_speed_hz

      self.spi_2 = spidev.SpiDev()
      self.spi_2.open(1, 2)
      self.spi_2.max_speed_hz = max_speed_hz
    #respond intervel (ms)
    GPIO.add_event_detect(self.GPIO_INPUT_PIN, GPIO.FALLING, callback=self.gpio_callback,bouncetime=1)
    self.isConnected = True

  def gpio_callback(self, channel):
    # print("Called GPIO callback method.")
    if self.adc_data_ready_count < valve:#limited date's length
      self.adc_data_ready_count = self.adc_data_ready_count + 1
      self.a = self.spi_0.xfer2([0xd0] + [0x00] * 3)[1:]  # foremost first
      self.a[0] = self.a[2] + (self.a[1] << 8) + (self.a[0] << 16)
      self.result = np.append(self.result, self.a[:1])


  def close(self):
    self.spi_write_reg(TI_ADS1293_CONFIG_REG, self.TI_ADS1293_CONFIG_REG_VALUE)

    if(self.leads == ECG_LEAD_TYPE.LEAD_05):
      self.spi_0.close()
    elif (self.leads == ECG_LEAD_TYPE.LEAD_12):
      self.spi_0.close()
      self.spi_1.close()
      self.spi_2.close()

    GPIO.cleanup()
    self.isConnected = False

#方法加入@property后，这个方法相当于一个属性，这个属性可以让用户进行使用，而且用户有没办法随意修改。
  @property
  def is_data_ready(self):
    return self.adc_data_ready_count
  @property
  def data_read(self):
    return self.result


  def reset_data_ready(self):
    self.adc_data_ready_count = 0
    self.result = 0


  @property
  def is_connected(self):
    return self.isConnected


  @property
  def data_ready_sleep_interval(self):
    return self._DATA_READY_SLEEP_INTERVAL


  def spi_write_reg(self, addr, value, channel=0):
    command = ADS1293_WRITE_BIT & addr
    result = None

    if (channel == 0):
      result = self.spi_0.xfer2([command, value])
    elif (channel == 1):
      result = self.spi_1.xfer2([command, value])
    elif (channel == 2):
      result = self.spi_2.xfer2([command, value])
    return result

  def init_channel_setting(self):
    if(self.leads == ECG_LEAD_TYPE.LEAD_05):
      self.init_channel_lead5()
    elif (self.leads == ECG_LEAD_TYPE.LEAD_12):
      self.init_channel_lead12()

  def _init_channel_lead5(self, BW=320, channel=0):
    self.spi_write_reg(0x00, 0x00, channel)#/* Main Configuration */
    self.spi_write_reg(0x01, 0x0a, channel)#/* Flex Routing Swich Control for Channel 1 */
    self.spi_write_reg(0x02, 0x1a, channel)#/* Flex Routing Swich Control for Channel 2 */
    self.spi_write_reg(0x03, 0x00, channel)#/* Flex Routing Swich Control for Channel 3 */

    self.spi_write_reg(0x04, 0x00, channel)#/* Flex Routing Swich Control for Pace Channel */
    self.spi_write_reg(0x05, 0x00, channel)#/* Flex Routing Swich Control for Battery Monitoriing */
    self.spi_write_reg(0x06, 0x08, channel)#/* Lead Off Detect Control */
    self.spi_write_reg(0x07, 0x00, channel)# /* Lead Off Detect Enable */
    self.spi_write_reg(0x08, 0x00, channel)#/* Lead Off Detect Current */
    self.spi_write_reg(0x09, 0x00, channel)#* AC Lead Off Detect Current */
    self.spi_write_reg(0x0a, 0x07, channel)#/* Common Mode Detect Enable */
    self.spi_write_reg(0x0b, 0x00, channel)#/* Commond Mode Detect Control */
    self.spi_write_reg(0x0c, 0x04, channel)#/* Right Leg Drive Control */
    self.spi_write_reg(0x0d, 0x00, channel)#/* Wilson Reference Input one Selection */
    self.spi_write_reg(0x0e, 0x00, channel)#/* Wilson Reference Input two Selection */
    self.spi_write_reg(0x0f, 0x00, channel)# /* Wilson Reference Input three Selection */
    self.spi_write_reg(0x10, 0x00, channel)#/* Wilson Reference Input Control */
    self.spi_write_reg(0x11, 0x00, channel)#/* Internal Reference Voltage Control */
    self.spi_write_reg(0x12, 0x04, channel)#/* Clock Source and Output Clock Control */
    self.spi_write_reg(0x13, 0x00, channel)#/* Analog Front-End Frequency and Resolution */
    self.spi_write_reg(0x14, 0x00, channel)#/* Analog Front-End Shutdown Control */
    self.spi_write_reg(0x15, 0x00, channel)#/* Analog Front-End Fault Detection Control */
    self.spi_write_reg(0x16, 0x00, channel)#/* Enable Dithering in Signma-Delta */
    self.spi_write_reg(0x17, 0x05, channel)#/* Analog Pace Channel Output Routing Control */

    self.spi_write_reg(0x21, 0x02, channel)#/* R2 Decimation Rate */
    self.spi_write_reg(0x22, 0x02, channel)# /* R3 Decimation Rate for Channel 1 */
    self.spi_write_reg(0x23, 0x02, channel)#/* R3 Decimation Rate for Channel 2 */
    self.spi_write_reg(0x24, 0x02, channel)#/* R3 Decimation Rate for Channel 3 */
    self.spi_write_reg(0x25, 0x00, channel)#/* 2x Pace Data Rate for all channels */
    self.spi_write_reg(0x26, 0x00, channel)#/* ECG Filters Disabled */
    self.spi_write_reg(0x27, 0x08, channel)#/* Data Ready Pin Source */
    self.spi_write_reg(0x28, 0x00, channel)#/* Sync Out Pin Source */
    self.spi_write_reg(0x29, 0x00, channel)#* Optional Mask Control for DRDYB Output */
    self.spi_write_reg(0x2a, 0x00, channel)#/* Mask Error on ALARMB Pin */
    self.spi_write_reg(0x2e, 0x33, channel)#/* Digital Filter for Analog Alarm Signals */
    self.spi_write_reg(0x2f, 0x30, channel)# /* Configure Channel for Loop Read Back Mode */



  def init_channel_lead5(self,BW=320, channel=0):
    self.spi_write_reg(TI_ADS1293_CONFIG_REG, self.TI_ADS1293_CONFIG_REG_VALUE, channel)
    self.spi_write_reg(TI_ADS1293_FLEX_CH1_CN_REG, 0x11, channel)
    self.spi_write_reg(TI_ADS1293_FLEX_CH2_CN_REG, 0x19, channel)
    self.spi_write_reg(TI_ADS1293_FLEX_CH3_CN_REG, 0x2E, channel)

    self.spi_write_reg(0x0A, 0x07, channel)
    self.spi_write_reg(0x0C, 0x04, channel)
    self.spi_write_reg(0x0D, 0x01, channel)
    self.spi_write_reg(0x0E, 0x02, channel)
    self.spi_write_reg(0x0F, 0x03, channel)
    self.spi_write_reg(0x10, 0x01, channel)

    self.spi_write_reg(0x12, 0x04, channel)
    self.spi_write_reg(0x13, 0x3f, channel)  # 高功耗模式
    self.spi_write_reg(TI_ADS1293_AFE_SHDN_CN_REG, 0x00, channel)
    self.spi_write_reg(TI_ADS1293_P_DRATE_REG, 0x03, channel)#r1=2
    if BW == 320: #odr=1600, bw=320
      self.spi_write_reg(TI_ADS1293_R2_RATE_REG, 0x08, channel) #R2 = 8
      self.spi_write_reg(TI_ADS1293_R3_RATE1_REG, 0x04, channel)#R3 = 8
      self.spi_write_reg(TI_ADS1293_R3_RATE2_REG, 0x04, channel)
      self.spi_write_reg(TI_ADS1293_R3_RATE3_REG, 0x04, channel)#R3 = 8

    elif BW == 110: #odr=533, bw=110
      self.spi_write_reg(TI_ADS1293_R2_RATE_REG, 0x04, channel) #R2 = 6
      self.spi_write_reg(TI_ADS1293_R3_RATE1_REG, 0x20, channel)#R3 = 32/01/20
      self.spi_write_reg(TI_ADS1293_R3_RATE2_REG, 0x20, channel)
      self.spi_write_reg(TI_ADS1293_R3_RATE3_REG, 0x20, channel)#R3 = 32//20

    elif BW == 40: # odr=200, bw=40
      self.spi_write_reg(TI_ADS1293_R2_RATE_REG, 0x08, channel) #R2 = 8
      self.spi_write_reg(TI_ADS1293_R3_RATE1_REG, 0x40, channel)#R3 = 64
      self.spi_write_reg(TI_ADS1293_R3_RATE2_REG, 0x40, channel)
      self.spi_write_reg(TI_ADS1293_R3_RATE3_REG, 0x40, channel)#R3 = 8

    elif BW == 175: # odr=200, bw=40
      self.spi_write_reg(TI_ADS1293_R2_RATE_REG, 0x02, channel) #R2 = 8
      self.spi_write_reg(TI_ADS1293_R3_RATE1_REG, 0x02, channel)#R3 = 64
      self.spi_write_reg(TI_ADS1293_R3_RATE2_REG, 0x02, channel)
      self.spi_write_reg(TI_ADS1293_R3_RATE3_REG, 0x02, channel)#R3 = 8

    self.spi_write_reg(0x27, 0x08, channel)
    #self.spi_write_reg(0x2F, 0x70, channel)
    self.spi_write_reg(0x2F, 0x40, channel)  # 只回传 ch3 = 0x40 ch2 = 0x20

  def init_channel_lead12(self):
    self.spi_write_reg(TI_ADS1293_CONFIG_REG, self.TI_ADS1293_CONFIG_REG_VALUE, ECG_CHAN_1)
    self.spi_write_reg(TI_ADS1293_FLEX_CH1_CN_REG, 0x11, ECG_CHAN_1)
    self.spi_write_reg(TI_ADS1293_FLEX_CH2_CN_REG, 0x19, ECG_CHAN_1)

    self.spi_write_reg(TI_ADS1293_CMDET_EN_REG, 0x07, ECG_CHAN_1)
    self.spi_write_reg(TI_ADS1293_RLD_CN_REG, 0x04, ECG_CHAN_1)

    self.spi_write_reg(TI_ADS1293_WILSON_EN1_REG, 0x01, ECG_CHAN_1)
    self.spi_write_reg(TI_ADS1293_WILSON_EN2_REG, 0x02, ECG_CHAN_1)
    self.spi_write_reg(TI_ADS1293_WILSON_EN3_REG, 0x03, ECG_CHAN_1)

    self.spi_write_reg(TI_ADS1293_OSC_CN_REG, 0x05, ECG_CHAN_1)

    self.spi_write_reg(TI_ADS1293_AFE_SHDN_CN_REG, 0x24, ECG_CHAN_1)

    self.spi_write_reg(TI_ADS1293_R2_RATE_REG, 0x02, ECG_CHAN_1)
    self.spi_write_reg(TI_ADS1293_R3_RATE1_REG, 0x02, ECG_CHAN_1)
    self.spi_write_reg(TI_ADS1293_R3_RATE2_REG, 0x02, ECG_CHAN_1)

    self.spi_write_reg(TI_ADS1293_DRDYB_SRC_REG, 0x08, ECG_CHAN_1)

    self.spi_write_reg(TI_ADS1293_SYNCOUTB_SRC_REG, 0x08, ECG_CHAN_1)

    self.spi_write_reg(TI_ADS1293_CH_CNFG_REG, 0x30, ECG_CHAN_1)

    self.__init_channel_lead12(ECG_CHAN_2)
    self.__init_channel_lead12(ECG_CHAN_3)


  def __init_channel_lead12(self, channel):
    self.spi_write_reg(TI_ADS1293_CONFIG_REG, self.TI_ADS1293_CONFIG_REG_VALUE, channel)
    self.spi_write_reg(TI_ADS1293_FLEX_CH1_CN_REG, 0x0C, channel)
    self.spi_write_reg(TI_ADS1293_FLEX_CH2_CN_REG, 0x14, channel)
    self.spi_write_reg(TI_ADS1293_FLEX_CH3_CN_REG, 0x1C, channel)

    self.spi_write_reg(TI_ADS1293_OSC_CN_REG, 0x06, channel)

    self.spi_write_reg(TI_ADS1293_AFE_SHDN_CN_REG, 0x00, channel)

    self.spi_write_reg(TI_ADS1293_R2_RATE_REG, 0x02, channel)
    self.spi_write_reg(TI_ADS1293_R3_RATE1_REG, 0x02, channel)
    self.spi_write_reg(TI_ADS1293_R3_RATE2_REG, 0x02, channel)
    self.spi_write_reg(TI_ADS1293_R3_RATE3_REG, 0x02, channel)

    self.spi_write_reg(TI_ADS1293_DRDYB_SRC_REG, 0x00, channel)
    self.spi_write_reg(TI_ADS1293_SYNCOUTB_SRC_REG, 0x40, channel)

    self.spi_write_reg(TI_ADS1293_CH_CNFG_REG, 0x70, channel)


  def spi_read_reg(self, addr, channel=0):
    command = ADS1293_READ_BIT | addr

    result = []
    if (channel == 0):
      result = self.spi_0.xfer2([command, 0x00])
    elif (channel == 1):
      result = self.spi_1.xfer2([command, 0x00])
    elif (channel == 2):
      result = self.spi_2.xfer2([command, 0x00])
    return result


  def spi_stream_read_reg(self, count, channel=0):
    data = []
    cmd = ADS1293_READ_BIT | TI_ADS1293_DATA_LOOP_REG
    commands = ([cmd] + [0x00] * count)

    if (channel == 0):
      data = self.spi_0.xfer2(commands)
    elif (channel == 1):
      data = self.spi_1.xfer2(commands)
    elif (channel == 2):
      data = self.spi_2.xfer2(commands)

    return data
